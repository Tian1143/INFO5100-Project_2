<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project 2 with Pan and Zoom</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/topojson@3"></script>
    <style>
        .country {
            fill: lightgrey;
            cursor: pointer;
        }
        
        .country.medal {
            fill: rgb(254, 254, 193);
        }
        
        .country:hover {
            fill: rgb(255, 178, 34);
        }
        
        .tooltip {
            position: absolute;
            text-align: center;
            width: 120px;
            height: auto;
            padding: 5px;
            font: 12px sans-serif;
            background: lightsteelblue;
            border: 0px;
            border-radius: 8px;
            pointer-events: none;
        }
        
        .label {
            font-size: 12px;
            text-anchor: middle;
            fill: black;
        }

        .reset-button {
            margin-top: 20px;
            padding: 5px 15px;
            font-size: 16px;
            cursor: pointer;
        }

        .yGdpGridlines .domain {
        display: none;
        }

        .yMetGridlines .domain {
        display: none;
        }
    
        .yGdpGridlines line {
        stroke: rgb(89, 89, 130);
        }

        .yMetGridlines line {
        stroke: lightcoral;
        }

        .yGdpAxis {
        color: navy;
        }

        .yMetAxis {
        color: lightcoral;
        }

        #button-bar {
        display: flex;   
        gap: 20px;              
        margin-top: none;        
        }

        #button-bar button {
        background-color: rgb(255, 255, 255);
        color: rgb(6, 95, 212);
        font-size: 16px;
        border: rgb(6, 95, 212);
        border-style: solid;
        border-width: 1px;
        border-radius: 2px;
        cursor: pointer;
        padding-top: 19px;
        padding-bottom: 19px;
        padding-left: 26px;
        padding-right: 26px;

        transition: background-color 0.15s,
        color 0.15s; 
        }

        #button-bar button:hover {
        background-color: rgb(6, 95, 212);
        color: white;
        }

        .title{
            font-size: 40px;
            text-align: center;
        }
    </style>
</head>
<body>
    <p class="title">Olympic Participation and Medal Wins by Country on 2023</p>
    <svg id="worldMap" height="700" width="1100" style="background-color: rgb(218, 235, 250); margin-left: 50px;"></svg>
    <button class="reset-button" onclick="resetZoom()">Reset</button>
    
    <div style="margin-left: 50px;">
    <svg id="medalChart" height="300" width="300" ></svg><!--style="margin-left: 60px; margin-top: 10px;"-->
    <svg id="gdpChart" height="300" width="300"></svg><!--style="margin-left: 60px; margin-top: 10px;"-->
    <svg id="populationChart" height="300" width="300" ></svg><!--style="margin-left: 60px; margin-top: 10px;"-->
    </div>
    <p class="title">GDP and Medals comparision between different countries.</p>
    <svg id="lineGraph" height="700" width="1000"></svg>
    <div id="button-bar"></div>
    <script>
        const svgMap = d3.select("#worldMap");
        const widthMap = svgMap.attr("width");
        const heightMap = svgMap.attr("height");
        const marginMap = { top: 20, right: 20, bottom: 20, left: 20 };
        const mapWidth = widthMap - marginMap.left - marginMap.right;
        const mapHeight = heightMap - marginMap.top - marginMap.bottom;

        
        const mapViewport = svgMap.append("g");

        const tooltip = d3.select("body").append("div").attr("class", "tooltip").style("opacity", 0);

        let maxMedals = 130;
        let maxGDP = 90000;
        let maxPopulation = 2000;

        const mapData = async function() {
            const world = await d3.json("countries_with_medals_no_antarctica.json");

            const countries = topojson.feature(world, world.objects.countries);
            const countriesMesh = topojson.mesh(world, world.objects.countries);

            const projection = d3.geoMercator().fitSize([mapWidth, mapHeight], countries);
            const path = d3.geoPath().projection(projection);

            mapViewport.selectAll("path.country")
                .data(countries.features)
                .join("path")
                .attr("class", d => d.properties.total > 0 ? "country medal" : "country")
                .attr("d", path)
                .on("mouseover", (event, d) => {
                    tooltip.transition().duration(200).style("opacity", .9);
                    tooltip.html(`${d.properties.name}`)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 28) + "px");
                })
                .on("mouseout", () => tooltip.transition().duration(500).style("opacity", 0))
                .on("click", (event, d) => {
                    displayMedalChart(d.properties);
                    displayGdpChart(d.properties);
                    displayPopulationChart(d.properties);

                    // Zoom into the selected country
                    zoomToCountry(d);
                });

            mapViewport.append("path")
                .datum(countriesMesh)
                .attr("fill", "none")
                .attr("d", path)
                .attr("stroke", "black")
                .attr("stroke-width", 1);

            
            const zoom = d3.zoom()
                .scaleExtent([1, 10]) 
                .on("zoom", (event) => {
                    mapViewport.attr("transform", event.transform);
                });

            svgMap.call(zoom);

            
            function zoomToCountry(countryData) {
                const [[x0, y0], [x1, y1]] = path.bounds(countryData); 
                const countryWidth = x1 - x0;
                const countryHeight = y1 - y0;
                const scale = Math.max(1, Math.min(8, 0.9 / Math.max(countryWidth / mapWidth, countryHeight / mapHeight)));
                const translate = [
                    mapWidth / 2 - scale * (x0 + x1) / 2,
                    mapHeight / 2 - scale * (y0 + y1) / 2
                ];

                svgMap.transition()
                    .duration(750)
                    .call(
                        zoom.transform,
                        d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale)
                    );
            }

            
            window.resetZoom = function() {
                
                svgMap.transition()
                    .duration(750)
                    .call(zoom.transform, d3.zoomIdentity);

                
                displayMedalChart({ gold: 0, silver: 0, bronze: 0, total: 0 });
                displayGdpChart({ gdp: 0 });
                displayPopulationChart({ population: 0 });
            }
        }

        function createChart(svgSelector, data, maxValue, color) {
            const svg = d3.select(svgSelector);
            svg.selectAll("*").remove();

            const margin = { top: 20, right: 20, bottom: 40, left: 60 };
            const width = svg.attr("width") - margin.left - margin.right;
            const height = svg.attr("height") - margin.top - margin.bottom;

            const chart = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

            const xScale = d3.scaleBand()
                             .domain(data.map(d => d.category))
                             .range([0, width])
                             .padding(0.1);

            const yScale = d3.scaleLinear()
                             .domain([0, maxValue])
                             .range([height, 0]);

            chart.append("g")
                 .attr("transform", `translate(0,${height})`)
                 .call(d3.axisBottom(xScale));

            chart.append("g")
                 .call(d3.axisLeft(yScale));

            
            chart.selectAll(".bar")
                 .data(data)
                 .join("rect")
                 .attr("class", "bar")
                 .attr("x", d => xScale(d.category))
                 .attr("y", d => yScale(d.value))
                 .attr("width", xScale.bandwidth())
                 .attr("height", d => height - yScale(d.value))
                 .attr("fill", color);

            
            chart.selectAll(".label")
                 .data(data)
                 .join("text")
                 .attr("class", "label")
                 .attr("x", d => xScale(d.category) + xScale.bandwidth() / 2)
                 .attr("y", d => yScale(d.value) - 5)
                 .text(d => d.value);
        }

        function displayMedalChart(data = {gold: 0, silver: 0, bronze: 0, total: 0}) {
            const medalData = [
                { category: "Gold", value: data.gold || 0 },
                { category: "Silver", value: data.silver || 0 },
                { category: "Bronze", value: data.bronze || 0 },
                { category: "Total", value: data.total || 0 }
            ];
            createChart("#medalChart", medalData, maxMedals, "steelblue");
        }

        function displayGdpChart(data = {gdp: 0}) {
            const gdpData = [{ category: "GDP", value: data.gdp || 0 }];
            createChart("#gdpChart", gdpData, maxGDP, "green");
        }

        function displayPopulationChart(data = {population: 0}) {
            const populationData = [{ category: "Population", value: data.population || 0 }];
            createChart("#populationChart", populationData, maxPopulation, "orange");
        }

        
        displayMedalChart();
        displayGdpChart();
        displayPopulationChart();
        
        mapData();

        // Line Graph
        const olympic = async () => {
        const olympicsData = await d3.csv("olympics.csv", d3.autoType);
        // console.log(olympicsData);

        // Line Graph
        const lineGraph = d3.select("#lineGraph");
        const widthL = +lineGraph.attr("width");
        const heightL = +lineGraph.attr("height");
        const marginL = { top: 10, right: 50, bottom: 80, left: 50 };
        const graphLWidth = widthL - marginL.left - marginL.right;
        const graphLHeight = heightL - marginL.top - marginL.bottom;

        let annotations = lineGraph.append("g").attr("id","annotations");
        let chartArea = lineGraph.append("g").attr("id","points")
                           .attr("transform",`translate(${marginL.left},${marginL.top})`);

        // Y axis - gdp
        const gdpExtent = d3.extent(olympicsData, d => d['gdp']);
        const gdpScale = d3.scaleLinear().domain(gdpExtent).range([graphLHeight, 0]);
        let gdpAxis = d3.axisLeft(gdpScale)
        let gdpGridlines = d3.axisLeft(gdpScale)
                              .tickSize(-graphLWidth-25)
                              .tickFormat("")
        annotations.append("g")
          .attr("class", "yGdpAxis")
          .attr("transform",`translate(${marginL.left-6},${marginL.top})`)
          .call(gdpAxis);
        annotations.append("g")
          .attr("class", "yGdpGridlines")
          .attr("transform",`translate(${marginL.left-6},${marginL.top})`)
          .call(gdpGridlines);

        // Y axis - metal
        const metalExtent = d3.extent(olympicsData, d => d['total']);
        const metalScale = d3.scaleLinear().domain(metalExtent).range([graphLHeight, 0]);
        let metalAxis = d3.axisRight(metalScale)
        let metalGridlines = d3.axisRight(metalScale)
                              .tickSize(-graphLWidth-25)
                              .tickFormat("")
        annotations.append("g")
          .attr("class", "yMetAxis")
          .attr("transform",`translate(${widthL-30},0)`)
          .call(metalAxis);
        annotations.append("g")
          .attr("class", "yMetGridlines")
          .attr("transform",`translate(${widthL-30},0)`)
          .call(metalGridlines);
      
        // X axis - country
        const country = d3.map(olympicsData, d => d.country) 
        const countryScale = d3.scalePoint().domain(country).range([0, graphLWidth]).padding(0.05);
        let bottomAxis = d3.axisBottom(countryScale);
        let bottomAxisG = annotations.append("g")
                                        .attr("class", "x axis")
                                        .attr("transform",`translate(${marginL.left},${graphLHeight+marginL.top+10})`);

        var gclineGen = d3.line()
                        .x( d => countryScale(d['country']) )
                        .y( d => gdpScale(d['gdp']) )
                        .curve(d3.curveMonotoneX);

        var mclineGen = d3.line()
                        .x( d => countryScale(d['country']) )
                        .y( d => metalScale(d['total']) )
                        .curve(d3.curveMonotoneX);

        function updateLine(region) {
            const filteredData = olympicsData.filter(d => d.region === region);

            countryScale.domain(filteredData.map(d => d.country));
            if (region === "Asia" || region === "Europe") {
                bottomAxisG.call(d3.axisBottom(countryScale))
                                .selectAll("text")
                                .style("text-anchor", "end")
                                .style("font-size", "14")
                                .attr("transform", "rotate(-30)");
            }
            else {
            bottomAxisG.call(d3.axisBottom(countryScale))
                                .selectAll("text")
                                .style("text-anchor", "middle")
                                .style("font-size", "14");
            }

            chartArea.selectAll("path").remove();
            chartArea.selectAll("circle").remove();
        
            chartArea.append("path")
                    .datum(filteredData)
                    .attr("class", "line")
                    .attr("fill", "none")
                    .attr("stroke", "steelblue")
                    .attr("stroke-width", 3)
                    .attr("d", gclineGen);

            chartArea.selectAll("circle.gdp").data(filteredData)
                    .join("circle")
                    .attr("r", 3)
                    .attr("fill", "navy")  
                    .attr("cx", d => countryScale(d['country']) )
                    .attr("cy", d => gdpScale(d['gdp']) );
            
            chartArea.append("path")
                    .datum(filteredData)
                    .attr("class", "line")
                    .attr("fill", "none")
                    .attr("stroke", "coral")
                    .attr("stroke-width", 3)
                    .attr("d", mclineGen);

            chartArea.selectAll("circle.met").data(filteredData)
                    .join("circle")
                    .attr("r", 3)
                    .attr("fill", "coral")   
                    .attr("cx", d => countryScale(d['country']) )
                    .attr("cy", d => metalScale(d['total']) );

        }

        var countryDict = {}
        olympicsData.forEach( d => {
            countryDict[d.region] = d.region;
        });
        console.log(countryDict);

        const allKeys = Object.keys(countryDict).sort();

        allKeys.forEach( d => {
        // For each year key, add a new button to the button bar
        d3.select("div#button-bar")
          .append("button")
          .text( d )
          .on("click", function() {
            updateLine( d );
          })
        });

      }

      olympic();
    </script>
</body>
</html>
